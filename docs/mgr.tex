\documentclass{article}
\usepackage[automake, acronym, nonumberlist, nopostdot]{glossaries}
\usepackage{cite}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{chngcntr}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{wasysym}
\graphicspath{ {./img/} }
\numberwithin{equation}{section}

\lstset
{
	basicstyle=\small\ttfamily,
	frame=bt,
	numbers=left,
	tabsize=2,
	captionpos=b,
	aboveskip=2em,
	belowskip=2em,
	breaklines=true
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Commands
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
\renewcommand{\lstlistingname}{Code listing}
\renewcommand{\lstlistlistingname}{List of code listings}

\newcommand{\mstate}[5] {
	\langle#1, #2, #3, #4, #5\rangle
}

\newcommand{\ipointsto}[3] {
	#1 \leadsto \texttt{#2} \text{ } #3
}

\newcommand{\sval}[2] {
	#1_\texttt{#2}
}

\newcommand{\setarrayitem}[3] {
	#1[#2 \mapsto #3]
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Create acronyms
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newacronym{cil}{CIL}{Common Intermediate Language}
\newacronym{msil}{MSIL}{Microsoft Intermediate Language}
\newacronym{il}{IL}{Intermediate Language}
\newacronym{cli}{CLI}{Common Language Infrastructure}
\newacronym{iso}{ISO}{International Organization for Standardization}
\newacronym{cts}{CTS}{Common Type System}
\newacronym{cls}{CLS}{Common Language Specification}
\newacronym{ves}{VES}{Virtual Execution System}
\newacronym{ast}{AST}{Abstract syntax tree}
\makeglossaries

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Begin document
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\counterwithin{lstlisting}{section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Contents
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Acronyms
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printglossary[type=\acronymtype]
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Figures
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\listoffigures
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	List of tables
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\listoftables
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Code listings
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstlistoflistings
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Introduction
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\subsection{The \acrlong{cli}}

\textit{The \acrfull{cli}} is a specification developed by \textit{Microsoft} and standardized by \textit{\acrshort{iso}} and \textit{ECMA International} \cite{isoStandard, ecmaStandard}. It describes executable code and an environment that allows numerous programming languages to be executed on various platforms.

The following four main aspects are covered by the \acrlong{cli} \cite{ecmaStandard}:
\begin{itemize}
	\item{
		\textbf{\textit{The \acrfull{cts}}} - a type system supporting types and operations found in many programming languages;
	}
	\item{
		\textbf{Metadata} - used for describing and referencing types defined by the \acrshort{cts};
	}
	\item{
		\textbf{\textit{The \acrfull{cls}}} - an agreement between language designers and framework designers specifying a subset of the \acrshort{cts} and a set of usage conventions;
	}
	\item{
		\textbf{\textit{The \acrfull{ves}}} - responsible for loading and executing programs written for the \acrshort{cli}.
	}
\end{itemize}

There are multiple implementations of the \acrshort{cli}, for instance: \textit{.NET Framework}, \textit{Shared Source Common Language Infrastructure Implementation}, \textit{.NET Core} and \textit{Mono}.

\subsection{The \acrlong{cil}}

\textit{The \acrfull{cil}} is also known as \textit{the \acrfull{msil}} or simply \textit{the \acrfull{il}} \cite{procsharp7}. It is an object-oriented programming language that is a part of the \acrshort{cli}. Each language compatible with the \acrshort{cli} is compiled into the \acrshort{cil}. Moreover, the \acrshort{cil} is the actual language executed by the \acrshort{ves}. The language is a reasonable compromise between user-friendly, high-level programming languages and low-level assemblers. Although the \acrshort{cil} is human-readable, it is still a stack-based language and writing programs manually is therefore quite difficult.

Technically, the \acrshort{cil} is just a set of over 200 instructions and it does not define a syntax for describing \textit{the \acrshort{cli} metadata}. There is another syntax called \textit{ILAsm} - an assembly language for the \acrshort{cil} \cite{ecmaStandard}. However, many sources refer to the \acrshort{cil} and ILAsm interchangeably. Thus, \textit{the \acrshort{cil}} means hereinafter the whole ILAsm syntax and \textit{the \acrshort{cil} instruction set} refers to the correct meaning of the \acrlong{cil}.

\begin{lstlisting}[
	caption={\textit{Hello world} program.},
	label={lst:hello_world}
]
.assembly extern mscorlib {}

.assembly HelloWorld {}

.method static public void main() cil managed
{
	.entrypoint
	.maxstack 1
	ldstr "Hello world!"
	call void [mscorlib]System.Console::WriteLine(string)
	ret
}
\end{lstlisting}

The difference between ILAsm and the \acrshort{cil} can be easily understood by analysing the \textit{Hello world} program shown in code listing \ref{lst:hello_world}. Lines 1-8 and 12 of the example contain the \acrshort{cli} metadata described in ILasm syntax whereas lines 9-11 contain actual \acrshort{cil} instructions. The detailed meaning of each line can be explained as follows:
\begin{itemize}
	\item{Line 1 informs that an external assembly (\texttt{mscorlib}) should be loaded.}
	\item{Line 3 defines the assembly that should be created as the result of the compiler.}
	\item{Line 5 declares a static public method (\texttt{main}). It also defines that the method contains \acrshort{cil} code.}
	\item{Line 6 begins the body of the \texttt{main} method.}
	\item{Line 7 informs that the method should be used as the entry point of the program - it should be called by the compiler as the very first method.}
	\item{Line 8 specifies the maximal size of the evaluation stack associated with the method.}
	\item{Line 9 contains a \texttt{ldstr} instruction. It tells the compiler to put the \textit{Hello world!} string onto the evaluation stack.}
	\item{Line 10 contains a \texttt{call} instruction. It tells the compiler to call the \texttt{WriteLine} method from the \texttt{System.Console} class defined in the \texttt{mscorlib} assembly.}
	\item{Line 11 contains a \texttt{ret} instruction. It tells the compiler to return the result of the method and to transfer the control to the next method on the call stack.}
	\item{Line 12 ends the body of the \texttt{main} method.}
\end{itemize}

\subsection{{\#\#\# TO DO: ZALOZENIA, CEL PRACY I ZAKONCZENIE WSTEPU \#\#\#}}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	The CIL instruction set
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The \acrshort{cil} instruction set}

In order to understand how the \acrshort{cil} instructions work, this section explains the concept of the global state and provides code examples introducing several \acrshort{cil} instructions. As the whole set contains more than 200 instructions, further information on each of them can be found in \cite{ecmaStandard} and \cite{isoStandard}. A full list of the instructions is also shown in tables \ref{tab:coverage1} and \ref{tab:coverage2} which illustrate whether each instruction was implemented in the final interpreter or not.

\subsection{The global state}
\label{sec:global_state}

The \acrshort{cli} can manage multiple threads of control at the same time. A single thread of control can be thought as a call stack consisting of multiple method states. Although all the threads of control are rather independent, they still can access multiple managed heaps allocated in the shared memory space \cite{ecmaStandard}. This concept is presented in figure \ref{fig:global_state}.

\begin{figure}
	\includegraphics[width=1\textwidth]{global_state.png}
    \centering
    \caption{The global state concept.}
    \label{fig:global_state}
\end{figure}

A single method state includes several items required for the \acrshort{ves} to execute the method \cite{ecmaStandard}, inter alia:
\begin{itemize}
	\item{an instruction pointer - it determines the next instruction that should be executed within the method;}
	\item{an evaluation stack - it stores evaluation values;}
	\item{a method information handle - it contains read-only method information;}
	\item{a local variable array;}
	\item{an argument array.}
\end{itemize}

Generally, a single instruction can be understood as a description of how to manipulate the corresponding method state - there are only a few exceptions to this rule. Some instructions only require access to the evaluation stack while some do need to change other parts of the global state. To better understand these differences, the examples below present a couple of instructions and describe what effect they have on the global state.

\subsection{The evaluation stack}

As described above, a method state contains an evaluation stack. While a rich set of data types can be represented in memory, only a very limited subset of those types are supported by the \acrshort{cli} on an evaluation stack. This subset consists of the following data types \cite{ecmaStandard}:
\begin{itemize}
	\item{\texttt{int32},}
	\item{\texttt{int64},}
	\item{\texttt{native int},}
	\item{\texttt{F} (a floating-point number),}
	\item{\texttt{O} (an object reference),}
	\item{\texttt{\&} (a managed pointer),}
	\item{\texttt{native unsigned int} (also an unmanaged pointer),}
	\item{a user-defined value type.}
\end{itemize}

\subsection{Stack transformations}
\label{sec:stackTransformations}

A stack transformation can be thought as a sequence of pop and / or push operations performed on an evaluation stack. The majority of the \acrshort{cil} instructions uses such a sequence to get some values from the corresponding stack or to push some values onto it. In order to describe and visualise the effect of an instruction, the following syntax is used:
\begin{itemize}
	\item{$S$ denotes an evaluation stack;}
	\item{$S \rightarrow S \cdot v_1 \cdot v_2 \cdot ... \cdot v_n$ denotes a stack transformation which is equivalent to pushing the values $v_1, v_2, ..., v_n$ onto the stack $S$;}
	\item{$S \cdot u_1 \cdot u_2 \cdot ... \cdot u_n \rightarrow S$ denotes a stack transformation which is equivalent to popping the values $u_1, u_2, ..., u_n$ from the stack $S$;}
	\item{$S \cdot u_1 \cdot u_2 \cdot ... \cdot u_n \rightarrow S \cdot v_1 \cdot v_2 \cdot ... \cdot v_m$ denotes a stack transformation which is equivalent to popping values $u_1, u_2, ..., u_n$ from the stack $S$ and then pushing the values $v_1, v_2, ..., v_m$ onto it.}
\end{itemize}

\subsection{Stack values}

To illustrate the difference between various stack values, the following syntax represents the value $v$ of the stack type \texttt{type}:
$$
	\sval{v}{type}
$$.
For instance:
\begin{itemize}
	\item{$\sval{0}{int32}$ represents $0$ of type \texttt{int32}}.
\end{itemize}

\subsection{Examples}
\label{sec:instruction_examples}

\subsubsection{\texttt{ldc.i4.0}}
\label{sec:desc_ldci40}

The \texttt{ldc.i4.0} instruction pushes $0$ onto the evaluation stack as \texttt{int32}. The corresponding stack transformation can be presented as follows \cite{ecmaStandard}:
$$
	S \rightarrow S \cdot 0_\texttt{int32}
$$

The program shown in code listing \ref{lst:ldci40} uses the instruction to push $0$ onto the stack and then writes out the top stack value ($0$) using the \texttt{call} instruction.

\begin{lstlisting}[
	caption={Usage of the \texttt{ldc.i4.0} instruction.},
	label={lst:ldci40}
]
.assembly extern mscorlib {}

.assembly HelloWorld {}

.method static public void main() cil managed
{
	.entrypoint
	.maxstack 1
	ldc.i4.0
	call void [mscorlib]System.Console::WriteLine(int32)
	ret
}
\end{lstlisting}

The \acrshort{cil} provides a number of similar instructions to push other constant values onto the stack: \texttt{ldc.i4.1}, \texttt{ldc.i4.2}, \texttt{ldc.i4.3}, \texttt{ldc.i4.4}, \texttt{ldc.i4.5}, \texttt{ldc.i4.6}, \texttt{ldc.i4.7}, \texttt{ldc.i4.8} and \texttt{ldc.i4.m1} (or \texttt{ldc.i4.M1}) which pushes $-1$ onto the stack.

\subsubsection{\texttt{stloc.0} and \texttt{ldloc.0}}
\label{sec:desc_stloc0_ldloc0}

The \texttt{stloc.0} instruction pops a value $v$ from the evaluation stack and moves it to the $0$-th position in the local variable array. Its stack transformation can be represented as follows \cite{ecmaStandard}:
$$
	S \cdot v \rightarrow S
$$

Conversely, the \texttt{ldloc.0} instruction loads the $0$-th local variable $v$ onto the evaluation stack and its stack transformation is \cite{ecmaStandard}:
$$
	S \rightarrow S \cdot v
$$

The program shown in code listing \ref{lst:stloc0_ldloc0} uses both instruction to store $7$ in the $0$-th local variable and then to load it onto the stack.

There are several similar instructions provided by the \acrshort{cil}: \texttt{stloc.1}, \texttt{stloc.2}, \texttt{stloc.3}, \texttt{stloc}, \texttt{stloc.s}, \texttt{ldloc.1}, \texttt{ldloc.2}, \texttt{ldloc.3}, \texttt{ldloc}, \texttt{ldloc.s}.

\begin{lstlisting}[
	caption={Usage of the \texttt{stloc.0} and \texttt{ldloc.0} instructions.},
	label={lst:stloc0_ldloc0}
]
.assembly extern mscorlib {}

.assembly HelloWorld {}

.method static public void main() cil managed
{
	.entrypoint
	.maxstack 1
	.locals init ([0] int32 n)
	ldc.i4.7
	stloc.0
	ldloc.0
	call void [mscorlib]System.Console::WriteLine(int32)
	ret
}
\end{lstlisting}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	The semantics
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The semantics}
\label{sec:semantics}

As described in \ref{sec:global_state}, an instruction can be thought as a description of how to manipulate the current global state. Examples of such informal descriptions can be found in \ref{sec:instruction_examples}. \cite{ecmaStandard} presents further examples but it does not provide any formal way to describe the \acrshort{cil} instructions and their semantics. Furthermore, the formal \acrshort{cil} semantics cannot be easily found among other sources. Thus, one of the goals of the thesis is to introduce a formal, mathematical model to represent the semantics of the \acrshort{cil}.

The semantics presented below is patterned upon the example of the \acrshort{cil} semantics presented in \cite{zychlaThesis}. However, this thesis attempts to simplify it and to represent the semantics on a higher level of abstraction.

\subsection{Code verifiability}

A full \acrshort{cli} implementation should involve a verification algorithm that is responsible for checking the correctness of instructions and local variables. Precisely, the algorithm requires all local variables to be initialised before executing a method. It also simulates all possible control flows and branches in order to verify each reachable instruction. Obviously, the algorithm cannot predict the actual values on the current evaluation stack but is still able to check their number and types \cite{expertIl}.

Since the algorithm itself is responsible for checking types, the semantics assumes all the values on the evaluation stack and local variables to be correct and verified. The interpreter described later was also implemented to handle valid programs only.

\subsection{The global state}

The global state described in \ref{sec:global_state} can be represented as an ordered pair
\begin{equation}
	\sigma = \langle\tau, \eta\rangle
\end{equation}
where $\sigma$ is a global state, $\tau$ is a set of states of the corresponding threads of control and $\eta$ is a set of states of the managed heaps.

The following formula could be potentially used to describe the semantics \cite{wierzbicki}:
\begin{equation}
\label{eq:wierzbickiFormula}
	\langle I, \sigma_1\rangle \rightarrow \sigma_2.
\end{equation}
It can be understood as follows: if the program is in the state $\sigma_1$ and it executes the instruction $I$, the result state is $\sigma_2$. However, formula \ref{eq:wierzbickiFormula} treats the state and the current instruction as separate beings while the global state of the \acrshort{cil} contains the instruction pointer hence the formula can be simplified:
\begin{equation}
\label{eq:wierzbickiFormula2}
	\sigma_1 \rightarrow \sigma_2.
\end{equation}.

\subsection{The execution state}
\label{sec:executionState}

Since the global state and its mathematical representation can be very complex, this section is to provide a simpler concept called hereinafter \textit{the execution state}. As a single instruction can only change a state of a single thread of control, there is no need to include the whole global state in the semantics. The execution state is then a part of the global state that could be potentially changed by an instruction and can be represented as an ordered pair:
\begin{equation}
\label{eq:executionState}
	\langle\gamma, \eta\rangle
\end{equation}
where $\gamma$ is the corresponding thread of control (its state) and $\eta$ is a set of states of the managed heaps.

The semantics can be now presented as formulas of the following shape:
\begin{equation}
\label{eq:simpleSemantics}
	\langle\gamma_1, \eta_1\rangle \rightarrow \langle\gamma_2, \eta_2\rangle.
\end{equation}
The formula has an analogous meaning to formula \ref{eq:wierzbickiFormula2} however it operates on the execution state while the rest of the global state remains unchanged. For transparency, the angle brackets can be now omitted.

\subsection{The method state}

As mentioned before, the state of a single thread of control can be understood as a call stack of method states. Thus a similar syntax to the one introduced in section \ref{sec:stackTransformations} is used to illustrate the changes made on a call stack. A single method state can be then described using a tuple
\begin{equation}
\label{eq:methodState}
	\mstate{I}{S}{M}{L}{A}
\end{equation}
where:
\begin{itemize}
	\item{$I$ is the instruction pointer},
	\item{$S$ is the evaluation stack},
	\item{$M$ is the method information handle},
	\item{$L$ is the local variable array},
	\item{$A$ is the argument array}.
\end{itemize}

\subsection{The final syntax}

Taken all together, the semantics of the \acrshort{cil} can be represented as a set of formulas of the following shape:
\begin{equation}
\label{eq:finalSyntax}
	\gamma_1 \cdot \mu_{1,1} \cdot ... \cdot \mu_{1,n}, \eta_1 \rightarrow \gamma_2 \cdot \mu_{2,1} \cdot ... \cdot \mu_{2,m}, \eta_2
\end{equation}
where
\begin{itemize}
	\item{$\gamma_1, \gamma_2$ are call stacks,}
	\item{$\mu_{1,1}, ..., \mu_{1,n}, \mu_{2, 1}, ..., \mu_{2, m}$ are method states,}
	\item{$\eta_1, \eta_2$ are sets of managed heaps.}
\end{itemize}

For instance, the following describes a transformation which pushes 0 of type \texttt{int32} onto the evaluation stack of the top method state:
$$
	\gamma \cdot \mstate{I}{S}{M}{L}{A}, \eta \rightarrow \gamma \cdot \mstate{I}{S \cdot 0_\texttt{int32}}{M}{L}{A}, \eta.
$$

\subsection{Instruction pointers}

To show what actually instruction is pointed by the instruction pointer $I$, the following formula is used:
\begin{equation}
	\ipointsto{I}{instruction}.
\end{equation}
No special mathematical syntax is used to describe various instruction types. For example, the following formula means that the instruction pointer $I$ points to a \texttt{ldc.i4.0} instruction:
$$
	\ipointsto{I}{ldc.i4.0}.
$$

Additionally, according to the syntax presented in \cite{zychlaThesis}, $I_n$ denotes hereinafter a pointer to the $n$-th instruction of a method.

\subsection{Arrays}

A single method state contains 2 different arrays: a local variable array and an argument array. An array $A$ can be represented as a function associating a single value to each natural number that is less than the length of the array. In order to formalise the changes made on arrays, the following term is used:
\begin{equation}
\label{eq:array_change}
	\setarrayitem{A}{n}{v}
\end{equation}
It can be understood as the array $A$ with the $n$-th element set to the value $v$. Formally \cite{zychlaThesis}:
\begin{equation}
\label{eq:array_change_formal}
	(\setarrayitem{A}{n}{v})(i) =
	\begin{cases}
		v		& \text{if } i = n,\\
		A(i)	& \text{otherwise.}
	\end{cases}
\end{equation}


\subsection{Examples}

This section follows the informal descriptions contained in \ref{sec:instruction_examples} and uses the conventions described above in order to specify the semantics of several \acrshort{cil} instructions which can be found in formulas \ref{eq:semantics_ldci40}-\ref{eq:semantics_last}.

\begin{equation}
\label{eq:semantics_ldci40}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{0}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.0}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci41}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{1}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.1}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci42}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{2}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.2}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci43}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{3}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.3}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci44}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{4}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.4}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci45}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{5}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.5}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci46}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{6}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.6}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci47}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{7}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.7}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci48}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{8}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.8}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci4m1}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{(-1)}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.m1}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci4M1}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{(-1)}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.M1}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci4s}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{v}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4.s}{v}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldci4}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot \sval{v}{int32}}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldc.i4}{v}}
\end{equation}

\begin{equation}
\label{eq:semantics_stloc0}
	\infer{
		\gamma \cdot \mstate{I_n}{S \cdot v}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S}{M}{\setarrayitem{L}{0}{v}}{A}, \eta
	}
	{\ipointsto{I_n}{stloc.0}}
\end{equation}

\begin{equation}
\label{eq:semantics_stloc1}
	\infer{
		\gamma \cdot \mstate{I_n}{S \cdot v}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S}{M}{\setarrayitem{L}{1}{v}}{A}, \eta
	}
	{\ipointsto{I_n}{stloc.1}}
\end{equation}

\begin{equation}
\label{eq:semantics_stloc2}
	\infer{
		\gamma \cdot \mstate{I_n}{S \cdot v}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S}{M}{\setarrayitem{L}{2}{v}}{A}, \eta
	}
	{\ipointsto{I_n}{stloc.2}}
\end{equation}

\begin{equation}
\label{eq:semantics_stloc3}
	\infer{
		\gamma \cdot \mstate{I_n}{S \cdot v}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S}{M}{\setarrayitem{L}{3}{v}}{A}, \eta
	}
	{\ipointsto{I_n}{stloc.3}}
\end{equation}

\begin{equation}
\label{eq:semantics_stlocs}
	\infer{
		\gamma \cdot \mstate{I_n}{S \cdot v}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S}{M}{\setarrayitem{L}{i}{v}}{A}, \eta
	}
	{\ipointsto{I_n}{stloc.s}{i}}
\end{equation}

\begin{equation}
\label{eq:semantics_stloc}
	\infer{
		\gamma \cdot \mstate{I_n}{S \cdot v}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S}{M}{\setarrayitem{L}{i}{v}}{A}, \eta
	}
	{\ipointsto{I_n}{stloc}{i}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldloc0}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot L(0)}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldloc.0}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldloc1}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot L(1)}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldloc.1}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldloc2}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot L(2)}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldloc.2}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldloc3}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot L(3)}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldloc.3}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldlocs}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot L(i)}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldloc.s}{i}}
\end{equation}

\begin{equation}
\label{eq:semantics_ldloc}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot L(i)}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{ldloc}{i}}
\end{equation}

\begin{equation}
\label{eq:semantics_nop}
	\infer{
		\gamma \cdot \mstate{I_n}{S}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{nop}}
\end{equation}

\begin{equation}
\label{eq:semantics_dup}
	\infer{
		\gamma \cdot \mstate{I_n}{S \cdot v}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S \cdot v \cdot v}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{dup}}
\end{equation}

\begin{equation}
\label{eq:semantics_pop}
	\infer{
		\gamma \cdot \mstate{I_n}{S \cdot v}{M}{L}{A}, \eta
			\rightarrow
		\gamma \cdot \mstate{I_{n+1}}{S}{M}{L}{A}, \eta
	}
	{\ipointsto{I_n}{pop}}
\end{equation}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	The interpreter
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The interpreter}

The main part of this thesis is the interpreter which reads a \acrshort{cil} source code and is able to execute it.

The process of interpreting source code is commonly split up into several phases \cite{compilerDesign}:
\begin{itemize}
	\item{\textit{Lexical analysis} is the initial step of processing the input source code. It reads the text and divides it into specific tokens.}
	\item{\textit{Syntax analysis} or \textit{parsing} - this step produces an \acrshort{ast} based on the list of tokens.}
	\item{\textit{Interpreting} - the last phase processes the \acrshort{ast} in order to evaluate expressions and execute statements.}
\end{itemize}

Since the thesis focuses mainly on the last step, the interpreter bases on an external library called \texttt{Irony} which allows to tokenise and parse the input source code in a very straightforward way. The library requires a definition of a context-free grammar that should be used to process the input code. An almost complete grammar of the \acrshort{cil} is provided in \cite{ecmaStandard} thus it was used as a sample. For instance, code listing \ref{lst:grammar} presents a rule implemented within the interpreter that corresponds to the one defined in the original grammar:
\begin{center}
\texttt{name1: id
| DOTTEDNAME
| name1 '.' name1;}
\end{center}
\begin{lstlisting}[
	caption={An example of the grammar definition within the interpreter.},
	label={lst:grammar}
]
name1.Rule =
	id |
	DOTTEDNAME |
	name1 + _(".") + name1;
\end{lstlisting}
The whole grammar implementation can be found in the repository, under the path:
\begin{center}
	\href{https://github.com/kvasnyk/CILantro/blob/master/CILantro/CILantro/Parsing/CilGrammar.cs}{\texttt{/CILantro/Parsing/CilGrammar.cs}}.
\end{center}

\subsection{Technical background}

In order to focus on the semantics of the \acrshort{cil} and not on data types, the interpreter has been written in \texttt{C\#} which is itself compiled into the \acrshort{cil} so it uses the same type system and the same external assemblies. The source code of the interpreter can be found under the following link:

\begin{center}
	\href{https://github.com/kvasnyk/CILantro/tree/master/CILantro}{https://github.com/kvasnyk/CILantro/tree/master/CILantro}.
\end{center}

The interpreter is a console application based on the \texttt{.NET Framework 4.7.2} so it can be executed in \texttt{Windows} operating system with the appropriate framework installed. The program can be run with the following command line argument:
\begin{itemize}
	\item{\texttt{--fileName} \texttt{\textit{fileName}} - a path to a text file containing the source code to be interpreted.}
\end{itemize}

The standard input, standard output and standard error streams are redirected to the console in order to allow the interpreted program to interact with the user. For instance, the program shown in code listing \ref{lst:hello_world} calls the \texttt{Console.WriteLine} method to write out the \textit{Hello world!} string to the standard output. The interpreter redirects the output therefore the string appears in the console. However, when an interpreter exception is caught, it is also written to the standard error stream.

\subsection{Detection of non-supported features}

Before interpreting the provided source code, the application checks if the code is supported by the interpreter. Once a non-supported feature is detected, one of the following exceptions is thrown and written out to the console:
\begin{itemize}
	\item{\texttt{InstructionNotSupportedException},}
	\item{\texttt{FeatureNotSupportedException}.}
\end{itemize}

\subsection{The actual interpreter}

In order to implement the interpreter, a couple of concepts described before needed to be modelled in \texttt{C\#}. While the semantics is an abstract description of the language that defines each instruction as a transformation of the execution state, it does not provide any details on how to implement the transformations or the execution state itself. This very chapter describes various approaches that could be followed to reflect some elements of the semantics in the implementation of an interpreter.

\subsubsection{The evaluation stack}

Potentially, the evaluation stack could be implemented as a simple stack that provides methods to pop and push values. There is the \texttt{Stack} class in the \texttt{C\#} standard library that meets these requirements. However, there are a couple of problems that need to be resolved while using such a model:
\begin{itemize}
	\item{many \acrshort{cil} instructions require more than one value to be popped or pushed at the same time;}
	\item{the evaluation stack can only operate on a very limited set of types;}
	\item{the \acrshort{cil} requires specific conversions between the standard types and the stack types while pushing or popping values.}
\end{itemize}

In order to avoid such problems, the evaluation stack has been implemented as a new class containing a private \texttt{Stack} instance. The class provides a number of useful \textit{pop} and \textit{push} methods that can operate on the limited set of stack types as well as other standard types. While calling a method, all the required conversions are made if possible or an exception is thrown. Additionally, the \texttt{CilEvaluationStack} class allows to call a method that pops or pushes several values at the same type. The source code of the class can be seen in the repository, under the following path: 
\begin{center}
\href{https://github.com/kvasnyk/CILantro/blob/master/CILantro/CILantro/Interpreting/State/CilEvaluationStack.cs}{\texttt{/CILantro/Interpreting/State/CilEvaluationStack.cs}}.
\end{center}

\subsubsection{The managed memory}

The semantics operates on a set of managed heaps. This thesis does not go into the detail and collectively treats all the managed heaps as \textit{the managed memory}. Ideally, the managed memory could be implemented by directly using the unmanaged memory. Such a solution is undoubtedly the most flexible and the most desired while implementing any interpreter.

Nevertheless, operating on the unmanaged memory might be really challenging using \texttt{C\#} as it is based on the managed memory itself. Alternatively, a simpler approach can be adopted - the managed memory can be simply simulated as a dictionary mapping addresses to objects. Using such an approach has its serious consequences - no unmanaged memory operations are allowed and the managed memory depends on the \texttt{C\#} managed memory.

As this thesis does not focus on the managed memory but on the semantics of the \acrshort{cil}, the managed memory has been implemented using the simpler method described above. The source code of the \texttt{CilDictionaryManagedMemory} can be found in the repository, under the path:
\begin{center}
	\href{https://github.com/kvasnyk/CILantro/blob/master/CILantro/CILantro/Interpreting/Memory/CilDictionaryManagedMemory.cs}{\texttt{/CILantro/Interpreting/Memory/CilDictionaryManagedMemory.cs}}
\end{center}

However, in order to make the implementation easy to change, there is an abstract class \texttt{CilManagedMemory} that could be potentially used to implement the managed memory in any other way, including the desired solution that involves the unmanaged memory.

\subsubsection{The state arrays}

There are 2 similar arrays included in a single method state: the local variable array and the argument array. They cannot be implemented as standard arrays as their elements must be accessible by a local variable name or an argument name respectively. In order to fulfil this criterion, the interpreter uses the \texttt{CilOrderedDictionary} class. It bases on the \texttt{OrderedDitionary} class from the \texttt{C\#} standard library that allows to access its elements by an index as well as a name. The class can be found in the repository, under the following path:
\begin{center}
	\href{https://github.com/kvasnyk/CILantro/blob/master/CILantro/CILantro/Interpreting/State/CilOrderedDictionary.cs}{\texttt{/CILantro/Interpreting/State/CilOrderedDictionary.cs}}
\end{center}

\subsubsection{The visitor}
\label{sec:visitor}

Since the semantics presented in \ref{sec:semantics} bases on transformations of the execution state, the same concept has been used to implement the interpreter. A single transformation of the state always depends on the current instruction pointer so the process of interpreting can be thought as visiting various instructions presented in the abstract syntax tree. To implement such a behaviour, a design pattern called \textit{Visitor} has been used. The pattern allows to write a new operation for each element of an object structure \cite{designPatterns}.

\texttt{CilInstructionsVisitor} is an abstract class which implements the Visitor design pattern. Its source code can be found in the repository, under the following path:
\begin{center}
\href{https://github.com/kvasnyk/CILantro/blob/master/CILantro/CILantro/Visitors/CilInstructionsVisitor.cs}{\texttt{/CILantro/Visitors/CilInstructionsVisitor.cs}}.
\end{center}
In order to make its implementation reusable, the class does not decide what instruction should be visited next. Instead, an abstract method \texttt{GetNextInstruction} is used. As the \acrshort{cil} instruction set contains around 200 instructions, the visitor itself has been split up into several smaller classes (called subvisitors) responsible for visiting instructions of different types. Each instruction has its corresponding abstract method in the subvisitors set that is called by the main \texttt{Visit} method once an instruction of the appropriate type is going to be visited.

Using such an abstract implementation allows to implement different types of visitors for the abstract syntax tree. For now, there is only one implementation - the \texttt{CilInterpreterInstructionsVisitor} class and its subvisitors. This implementation uses the execution state to implement the \texttt{GetNextInstruction} method. To be precise, the instruction pointer of the top method state is used to determine the next instruction to visit.

\subsection{Examples}

Having the abstract visitors structure described in the previous section, implementing the interpreter is equivalent to completing the implementation of all of the abstract methods of the subvisitors. The implementation itself is based on the semantics described in \ref{sec:semantics}.

\subsubsection{\texttt{ldc.i4.0}}

The \texttt{VisitLoadConstI40Intruction} method shown in listing \ref{lst:visitldci40} corresponds to the \texttt{ldc.i4.0} instruction described in \ref{sec:desc_ldci40} with its semantics presented in formula \ref{eq:semantics_ldci40}. The meaning of the method can be explained as follows:
\begin{itemize}
	\item{Line 3 creates a new stack value of type \texttt{int32} with value equal to \texttt{0}.}
	\item{Line 4 pushes the newly created value to the top of the evaluation stack. \texttt{ControlState.EvaluationStack} is just a shorthand for accessing the evaluation stack of the top method state.}
	\item{Line 6 moves the instruction pointer of the top method state to the next instruction of the same method. The \texttt{MoveToNextInstruction} method is just a helper as such an operation is used very often.}
\end{itemize}

\begin{lstlisting}[
	caption={The \texttt{VisitLoadConstI40Intruction} method.},
	label={lst:visitldci40}
]
protected override void VisitLoadConstI40Intruction(LoadConstI40Instruction instruction)
{
	var stackVal = new CilStackValueInt32(0);
	ControlState.EvaluationStack.Push(stackVal);

	ControlState.MoveToNextInstruction();
}
\end{lstlisting}

\subsubsection{\texttt{stloc.0}}

The \texttt{VisitStoreLocal0Instruction} method is shown in listing \ref{lst:visitstloc0}. It is related to the \texttt{stloc.0} instruction described in \ref{sec:desc_stloc0_ldloc0} and its semantics presented in formula \ref{eq:semantics_stloc0}. The implementation can be understood as follows:


\begin{lstlisting}[
	caption={The \texttt{VisitSetLocal0Instruction} method.},
	label={lst:visitstloc0}
]
protected override void VisitStoreLocal0Instruction(StoreLocal0Instruction instruction)
{
	var localType = ControlState.Locals.GetLocalType(null, 0);
	ControlState.EvaluationStack.PopValue(_program, localType, out var value);
	ControlState.Locals.Store(null, 0, value);

	ControlState.MoveToNextInstruction();
}
\end{lstlisting}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Testing
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Testing}

Writing an interpreter of such a complex programming language as the \acrshort{cil} may be a little complicated. Implementing all the visit instructions at the same time seems to be impossible so a specific methodology needed to be arranged in order to achieve the desired effect. As a common approach in software development, an iterative methodology was introduced. Since the main goal of the thesis was to create an interpreter and maximise its compatibility with the \acrshort{cil} specification, the methodology was based on the following assumption - the main goal of each iteration is to increase the compatibility of the interpreter and the coverage of the \acrshort{cil} instruction set. The methodology can be also described as a specific process consisting of 4 steps:
\begin{enumerate}
	\item{Write a test.}
	\item{Cover the implementation of the interpreter so that the test passes.}
	\item{Run all the existing tests.}
	\item{Correct the implementation so that all the tests pass.}
	\item{Repeat steps 1-4.}
\end{enumerate}
The process is illustrated in figure \ref{fig:process}.

\begin{figure}
	\includegraphics[width=1\textwidth]{process.jpg}
    \centering
    \caption{The process of implementing the interpreter.}
    \label{fig:process}
\end{figure}

\subsection{The tests}

Potentially, a set of unit tests could be written based on the documentation and the semantics of each instruction. Nevertheless, such a task might be very difficult so another type of tests was used instead. Since there are functioning implementations of the \acrshort{cli}, working of the interpreter can be compared to working of one of such implementations. To be exact, the \texttt{.NET Framework 4.7.2} was selected to write the tests.

Taking into account the abilities of the interpreter, only console programs writing to the standard input, reading from the standard outuput and using the standard error stream are considered proper tests. The vast majority of the tests are written in \texttt{C\#}. Using the \texttt{ildasm} tool provided together with the \texttt{.NET Framework}, the tests can be decompiled to their \acrshort{cil} source code which can be then used as the input file for the interpreter. 

Once a test is prepared, it can be executed using the interpreter and the result of the execution can be compared to the result of the original test program. The result of such a comparison is assumed to be correct when the output produced by the interpreter is the same as the output produced by the original program for the same input. Even though a single test can be potentially executed using an infinite set of different inputs, only a small part is used so that the process is not too time-consuming. In order to make the process as reliable as possible, a set of random inputs is prepared every time the test is executed.

\subsection{The environment}

Since repeating the process described above manually might be arduous for bigger numbers of tests, a dedicated system was written separately to automate the procedure. The system is hereinafter called \textit{the tools} or \textit{the environment}. It comprises 2 projects:
\begin{itemize}
	\item{a back-end application,}
	\item{a front-end application.}
\end{itemize}

The back-end application is built using \texttt{ASP.NET Core} which is a modern framework for building Web APIs and applications \cite{littleAsp}. It provides a set of API actions and socket connections that were designed to handle tests, their categories and executions. The application uses a database to store all the data collected so far.

The front-end application was written in \texttt{Typescript} using \texttt{React.js} which is a popular library created for building user interfaces \cite{learningReact}. It is a single-page application that interacts with users and communicates with the back-end application in order to send or receive data.

The tools provide several functionalities described below.

\subsubsection{Finding tests}

The environment watches the folder provided in the configuration and displays a list of the new tests that have been found. Each of the found tests can be then saved in the database and used to perform various operations. An example of the functionality is shown in figure \ref{fig:tools_find}.

\begin{figure}
	\includegraphics[width=1\textwidth]{tools_find.png}
    \centering
    \caption{The environment - the \textit{Find tests} functionality.}
    \label{fig:tools_find}
\end{figure}

\subsubsection{Managing categories}

The tools allow the user to define categories and subcategories that can be listed, ordered and filtered. The categories and the subcategories can be then assigned to the tests. The \textit{Categories} page is shown in figure \ref{fig:tools_categories}.

\begin{figure}
	\includegraphics[width=1\textwidth]{tools_categories.png}
    \centering
    \caption{The environment - the \textit{Categories} page.}
    \label{fig:tools_categories}
\end{figure}

\subsubsection{Managing tests}

The tests can be also listed, ordered and filtered. Each test is presented as a single card of a specific colour which determines the state of the test. If a card is grey, the related test is not configured and needs some additional attention - the card contains a list of tasks to be done in order to configure the test properly. If a card is purple, the corresponding test has been marked as unsupported. If a card is white, the test is ready to be used and run. Additionally, if a test has been already run, the card shows an icon that represents the result of the last run of the test. The \textit{Tests} page is shown in figure \ref{fig:tools_tests}.

\begin{figure}
	\includegraphics[width=1\textwidth]{tools_tests.png}
    \centering
    \caption{The environment - the \textit{Tests} page.}
    \label{fig:tools_tests}
\end{figure}

\subsubsection{Managing a single test}

The details of each test defined in the application can be shown on a separate page. The page is divided into the following tabs:
\begin{itemize}
	\item{\texttt{OVERVIEW} - it shows some basic information about the test such as its category and subcategory};
	\item{\texttt{IL SOURCES} - allows the user to display and regenerate the main \texttt{.il} file containing the \acrshort{cil} source code of the test};
	\item{\texttt{EXE} - can be used to compile the source code into an executable file required to execute the test};
	\item{\texttt{I/O} - used for defining example inputs and the pattern of input accepted by the test}.
\end{itemize}

Above the tabs, there is an action area that allows the user to:
\begin{itemize}
	\item{run the original program, the interpreter or both at the same time};
	\item{schedule a test run for the test};
	\item{mark the test as supported or non-supported}.
\end{itemize}

Figure \ref{fig:tools_test} shows a single test page while figure \ref{fig:tools_run_both} presents an example of executing both the original program and the interpreter using the comparison view.

\begin{figure}
	\includegraphics[width=1\textwidth]{tools_test.png}
    \centering
    \caption{The environment - an example test page.}
    \label{fig:tools_test}
\end{figure}

\begin{figure}
	\includegraphics[width=1\textwidth]{tools_run_both.png}
    \centering
    \caption{The environment - running a test in the comparison view.}
    \label{fig:tools_run_both}
\end{figure}

\subsubsection{Managing test runs}

The test runs can be listed, ordered and filter. A single run is represented by a card of a specific colour. If a card is orange, the corresponding run is being executed at the moment. If a card is red, the run has already ended but its result is wrong. If a card is green, the related run has ended and the result is correct. Each run can be also restarted and the user can display its details.

The page contains two buttons that start a single test run including all the well-configured tests. There are two types of runs: quick and full. A quick run executes each test using only 3 random inputs while a full run uses 100 random inputs for each test. Regardless of the type, each run also executes the tests using the inputs defined in the tools. The \textit{Test runs} page is shown in figure \ref{fig:tools_runs}.

\begin{figure}
	\includegraphics[width=1\textwidth]{tools_runs.png}
    \centering
    \caption{The environment - the \textit{Test runs} page.}
    \label{fig:tools_runs}
\end{figure}

\subsubsection{Managing a single test run}

Once a test run is finished, its details can be viewed on a separate page. The page contains a card for each test that has been executed within the test run. A card is red if the corresponding test ended with a wrong result and green otherwise. The environment allows the user to open a card and access the details of the executed test. An open card shows a table where each input is represented by a single row containing icons that show the result of each of the following execution phases:
\begin{itemize}
	\item{generating input},
	\item{executing the original program},
	\item{executing the interpreter},
	\item{comparing the results}.
\end{itemize}
Additionally, each row can be also opened in order to see the input and the outputs of the original program and the interpreter. An example of the functionality is shown in figure \ref{fig:tools_run}.

\begin{figure}
	\includegraphics[width=1\textwidth]{tools_run.png}
    \centering
    \caption{The environment - the \textit{Test run} functionality.}
    \label{fig:tools_run}
\end{figure}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Results
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Results}

\begin{table}
\begin{center}
	\begin{tabular}{|cc||cc||cc|}
\hline
\texttt{nop} & \Circle & \texttt{pop} & \Circle & \texttt{ldind.u4} & \Circle \\ \hline
\texttt{break} & \Circle & \texttt{jmp} & \Circle & \texttt{ldind.i8} & \Circle \\ \hline
\texttt{ldarg.0} & \Circle & \texttt{call} & \Circle & \texttt{ldind.i} & \Circle \\ \hline
\texttt{ldarg.1} & \Circle & \texttt{calli} & \Circle & \texttt{ldind.r4} & \Circle \\ \hline
\texttt{ldarg.2} & \Circle & \texttt{ret} & \Circle & \texttt{ldind.r8} & \Circle \\ \hline
\texttt{ldarg.3} & \Circle & \texttt{br.s} & \Circle & \texttt{ldind.ref} & \Circle \\ \hline
\texttt{ldloc.0} & \Circle & \texttt{brfalse.s} & \Circle & \texttt{stind.ref} & \Circle \\ \hline
\texttt{ldloc.1} & \Circle & \texttt{brtrue.s} & \Circle & \texttt{stind.i1} & \Circle \\ \hline
\texttt{ldloc.2} & \Circle & \texttt{beq.s} & \Circle & \texttt{stind.i2} & \Circle \\ \hline
\texttt{ldloc.3} & \Circle & \texttt{bge.s} & \Circle & \texttt{stind.i4} & \Circle \\ \hline
\texttt{stloc.0} & \Circle & \texttt{bgt.s} & \Circle & \texttt{stind.i8} & \Circle \\ \hline
\texttt{stloc.1} & \Circle & \texttt{ble.s} & \Circle & \texttt{stind.r4} & \Circle \\ \hline
\texttt{stloc.2} & \Circle & \texttt{blt.s} & \Circle & \texttt{stind.r8} & \Circle \\ \hline
\texttt{stloc.3} & \Circle & \texttt{bne.un.s} & \Circle & \texttt{add} & \Circle \\ \hline
\texttt{ldarg.s} & \Circle & \texttt{bge.un.s} & \Circle & \texttt{sub} & \Circle \\ \hline
\texttt{ldarga.s} & \Circle & \texttt{bgt.un.s} & \Circle & \texttt{mul} & \Circle \\ \hline
\texttt{starg.s} & \Circle & \texttt{ble.un.s} & \Circle & \texttt{div} & \Circle \\ \hline
\texttt{ldloc.s} & \Circle & \texttt{blt.un.s} & \Circle & \texttt{div.un} & \Circle \\ \hline
\texttt{ldloca.s} & \Circle & \texttt{br} & \Circle & \texttt{rem} & \Circle \\ \hline
\texttt{stloc.s} & \Circle & \texttt{brfalse} & \Circle & \texttt{rem.un} & \Circle \\ \hline
\texttt{ldnull} & \Circle & \texttt{brtrue} & \Circle & \texttt{and} & \Circle \\ \hline
\texttt{ldc.i4.m1} & \Circle & \texttt{beq} & \Circle & \texttt{or} & \Circle \\ \hline
\texttt{ldc.i4.0} & \Circle & \texttt{bge} & \Circle & \texttt{xor} & \Circle \\ \hline
\texttt{ldc.i4.1} & \Circle & \texttt{bgt} & \Circle & \texttt{shl} & \Circle \\ \hline
\texttt{ldc.i4.2} & \Circle & \texttt{ble} & \Circle & \texttt{shr} & \Circle \\ \hline
\texttt{ldc.i4.3} & \Circle & \texttt{blt} & \Circle & \texttt{shr.un} & \Circle \\ \hline
\texttt{ldc.i4.4} & \Circle & \texttt{bne.un} & \Circle & \texttt{neg} & \Circle \\ \hline
\texttt{ldc.i4.5} & \Circle & \texttt{bge.un} & \Circle & \texttt{not} & \Circle \\ \hline
\texttt{ldc.i4.6} & \Circle & \texttt{bgt.un} & \Circle & \texttt{conv.i1} & \Circle \\ \hline
\texttt{ldc.i4.7} & \Circle & \texttt{ble.un} & \Circle & \texttt{conv.i2} & \Circle \\ \hline
\texttt{ldc.i4.8} & \Circle & \texttt{blt.un} & \Circle & \texttt{conv.i4} & \Circle \\ \hline
\texttt{ldc.i4.s} & \Circle & \texttt{switch} & \Circle & \texttt{conv.i8} & \Circle \\ \hline
\texttt{ldc.i4} & \Circle & \texttt{ldind.i1} & \Circle & \texttt{conv.r4} & \Circle \\ \hline
\texttt{ldc.i8} & \Circle & \texttt{ldind.u1} & \Circle & \texttt{conv.r8} & \Circle \\ \hline
\texttt{ldc.r4} & \Circle & \texttt{ldind.i2} & \Circle & \texttt{conv.u4} & \Circle \\ \hline
\texttt{ldc.r8} & \Circle & \texttt{ldind.u2} & \Circle & \texttt{conv.u8} & \Circle \\ \hline
\texttt{dup} & \Circle & \texttt{ldind.i4} & \Circle & \texttt{callvirt} & \Circle \\ \hline
	\end{tabular}
\caption{The \acrshort{cil} instructions covered by the interpreter (part 1 of 2).}
\label{tab:coverage1}
\end{center}
\end{table}

\begin{table}
\begin{center}
	\begin{tabular}{|cc||cc||cc|}
\hline
\texttt{cpobj} & \Circle & \texttt{ldelem.i} & \Circle & \texttt{sub.ovf.un} & \Circle \\ \hline
\texttt{ldobj} & \Circle & \texttt{ldelem.r4} & \Circle & \texttt{endfinally} & \Circle \\ \hline
\texttt{ldstr} & \Circle & \texttt{ldelem.r8} & \Circle & \texttt{leave} & \Circle \\ \hline
\texttt{newobj} & \Circle & \texttt{ldelem.ref} & \Circle & \texttt{leave.s} & \Circle \\ \hline
\texttt{castclass} & \Circle & \texttt{stelem.i} & \Circle & \texttt{stind.i} & \Circle \\ \hline
\texttt{isinst} & \Circle & \texttt{stelem.i1} & \Circle & \texttt{conv.u} & \Circle \\ \hline
\texttt{conv.r.un} & \Circle & \texttt{stelem.i2} & \Circle & \texttt{arglist} & \Circle \\ \hline
\texttt{unbox} & \Circle & \texttt{stelem.i4} & \Circle & \texttt{ceq} & \Circle \\ \hline
\texttt{throw} & \Circle & \texttt{stelem.i8} & \Circle & \texttt{cgt} & \Circle \\ \hline
\texttt{ldfld} & \Circle & \texttt{stelem.r4} & \Circle & \texttt{cgt.un} & \Circle \\ \hline
\texttt{ldflda} & \Circle & \texttt{stelem.r8} & \Circle & \texttt{clt} & \Circle \\ \hline
\texttt{stfld} & \Circle & \texttt{stelem.ref} & \Circle & \texttt{clt.un} & \Circle \\ \hline
\texttt{ldsfld} & \Circle & \texttt{ldelem} & \Circle & \texttt{ldftn} & \Circle \\ \hline
\texttt{ldsflda} & \Circle & \texttt{stelem} & \Circle & \texttt{ldvirtftn} & \Circle \\ \hline
\texttt{stsfld} & \Circle & \texttt{unbox.any} & \Circle & \texttt{ldarg} & \Circle \\ \hline
\texttt{stobj} & \Circle & \texttt{conv.ovf.i1} & \Circle & \texttt{ldarga} & \Circle \\ \hline
\texttt{conv.ovf.i1.un} & \Circle & \texttt{conv.ovf.u1} & \Circle & \texttt{starg} & \Circle \\ \hline
\texttt{conv.ovf.i2.un} & \Circle & \texttt{conv.ovf.i2} & \Circle & \texttt{ldloc} & \Circle \\ \hline
\texttt{conv.ovf.i4.un} & \Circle & \texttt{conv.ovf.u2} & \Circle & \texttt{ldloca} & \Circle \\ \hline
\texttt{conv.ovf.i8.un} & \Circle & \texttt{conv.ovf.i4} & \Circle & \texttt{stloc} & \Circle \\ \hline
\texttt{conv.ovf.u1.un} & \Circle & \texttt{conv.ovf.u4} & \Circle & \texttt{localloc} & \Circle \\ \hline
\texttt{conv.ovf.u2.un} & \Circle & \texttt{conv.ovf.i8} & \Circle & \texttt{endfilter} & \Circle \\ \hline
\texttt{conv.ovf.u4.un} & \Circle & \texttt{conv.ovf.u8} & \Circle & \texttt{unaligned.} & \Circle \\ \hline
\texttt{conv.ovf.u8.un} & \Circle & \texttt{refanyval} & \Circle & \texttt{volatile.} & \Circle \\ \hline
\texttt{conv.ovf.i.un} & \Circle & \texttt{ckfinite} & \Circle & \texttt{tail.} & \Circle \\ \hline
\texttt{conv.ovf.u.un} & \Circle & \texttt{mkrefany} & \Circle & \texttt{Initobj} & \Circle \\ \hline
\texttt{box} & \Circle & \texttt{ldtoken} & \Circle & \texttt{constrained.} & \Circle \\ \hline
\texttt{newarr} & \Circle & \texttt{conv.u2} & \Circle & \texttt{cpblk} & \Circle \\ \hline
\texttt{ldlen} & \Circle & \texttt{conv.u1} & \Circle & \texttt{initblk} & \Circle \\ \hline
\texttt{ldelema} & \Circle & \texttt{conv.i} & \Circle & \texttt{no.} & \Circle \\ \hline
\texttt{ldelem.i1} & \Circle & \texttt{conv.ovf.i} & \Circle & \texttt{rethrow} & \Circle \\ \hline
\texttt{ldelem.u1} & \Circle & \texttt{conv.ovf.u} & \Circle & \texttt{sizeof} & \Circle \\ \hline
\texttt{ldelem.i2} & \Circle & \texttt{add.ovf} & \Circle & \texttt{Refanytype} & \Circle \\ \hline
\texttt{ldelem.u2} & \Circle & \texttt{add.ovf.un} & \Circle & \texttt{readonly.} & \Circle \\ \hline
\texttt{ldelem.i4} & \Circle & \texttt{mul.ovf} & \Circle &  &  \\ \hline
\texttt{ldelem.u4} & \Circle & \texttt{mul.ovf.un} & \Circle &  &  \\ \hline
\texttt{ldelem.i8} & \Circle & \texttt{sub.ovf} & \Circle &  &  \\ \hline
	\end{tabular}
\caption{The \acrshort{cil} instructions covered by the interpreter (part 2 of 2).}
\label{tab:coverage2}
\end{center}
\end{table}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Conclusions & future work
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusions and future work}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	Bibliography
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\refname}{Bibliography}

\bibliography{mgr}{}
\bibliographystyle{unsrt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%%%%%	End document
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}